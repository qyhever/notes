- [**一、缓存穿透（Cache Penetration）**](#一缓存穿透cache-penetration)
  - [**定义**](#定义)
  - [**核心特征**](#核心特征)
  - [**实际场景**](#实际场景)
  - [**示例**](#示例)
- [**二、缓存雪崩（Cache Avalanche）**](#二缓存雪崩cache-avalanche)
  - [**定义**](#定义-1)
  - [**核心特征**](#核心特征-1)
  - [**实际场景**](#实际场景-1)
  - [**示例**](#示例-1)
- [**三、缓存击穿（Cache Breakdown）**](#三缓存击穿cache-breakdown)
  - [**定义**](#定义-2)
  - [**核心特征**](#核心特征-2)
  - [**实际场景**](#实际场景-2)
  - [**示例**](#示例-2)
- [**四、三者区别对比**](#四三者区别对比)
- [**五、解决方案**](#五解决方案)
  - [**缓存穿透**](#缓存穿透)
  - [**缓存雪崩**](#缓存雪崩)
  - [**缓存击穿**](#缓存击穿)
- [**总结**](#总结)
- [Reference](#reference)


定义：
1. 缓存穿透：查询不存在的数据，导致请求直接打到数据库，绕过缓存。
2. 缓存雪崩：大量缓存同时失效，导致请求全部涌入数据库，造成压力。
3. 缓存击穿：热点键过期，大量请求同时访问该键，导致数据库压力骤增。

具体的例子：
1. 缓存穿透可能是恶意攻击或错误查询。
2. 缓存雪崩可能是缓存过期时间设置不合理。
3. 缓存击穿可能是热点数据未及时更新。

需要注意区分三者的核心差异：
1. 缓存穿透是查不到数据。
2. 缓存雪崩是大量缓存失效。
3. 缓存击穿是单个热点缓存失效。

缓存穿透、缓存雪崩、缓存击穿是分布式系统中常见的缓存问题，三者核心差异在于**触发原因**和**影响范围**，但最终都会导致数据库压力激增甚至崩溃。以下从定义、区别、实际场景和解决方案四个维度详细说明：

### **一、缓存穿透（Cache Penetration）**

#### **定义**  

缓存穿透是指**查询一个数据库中根本不存在的数据**时，请求会直接绕过缓存（因为缓存中没有），最终打到数据库。由于数据库中也无该数据，每次请求都会穿透到数据库，导致无效查询。

#### **核心特征**  

- **查询对象不存在**：目标是数据库中无记录的数据（如无效ID、非法参数）。  
- **缓存无法拦截**：缓存中没有对应键，无法过滤请求。  

#### **实际场景**  

- **恶意攻击**：攻击者构造大量不存在的ID（如`user_id=-1`）频繁请求，绕过缓存直接查数据库。  
- **业务逻辑漏洞**：前端未校验参数合法性（如商品ID为负数），导致后端接收到无效查询。  

#### **示例**  

假设数据库中只有`user_id=1~1000`的用户数据，攻击者发送`user_id=9999`的查询请求：  

- 缓存中无`user:9999`的键 → 请求打到数据库。  
- 数据库查询`user_id=9999`无结果 → 返回空。  
- 后续所有`user_id=9999`的请求都会重复上述过程，数据库压力激增。  

### **二、缓存雪崩（Cache Avalanche）**

#### **定义**  

缓存雪崩是指**大量缓存在同一时间集中失效**（或缓存服务宕机），导致原本被缓存拦截的请求全部涌入数据库，超出数据库承受能力，引发性能崩溃。

#### **核心特征**  

- **批量失效**：大量缓存的过期时间（TTL）集中设置（如同一时间过期）。  
- **数据库压力骤增**：缓存失效后，所有请求同时转向数据库。  

#### **实际场景**  

- **TTL设置不合理**：业务上线时为方便，将所有缓存的TTL统一设为`24:00:00`（如活动结束后统一失效）。  
- **缓存服务故障**：Redis集群宕机，所有缓存不可用，请求直接打数据库（此时即使缓存未过期，也因服务不可用而失效）。  

#### **示例**  

某电商大促活动中，为提升性能，所有商品详情页的缓存TTL统一设置为`2024-11-11 23:59:59`（活动结束时间）。活动结束后，大量用户仍访问商品详情页：  

- 所有商品缓存同时失效 → 请求全部涌入数据库。  
- 数据库瞬间承受数万次查询（远超平时负载）→ 响应变慢甚至宕机。  

### **三、缓存击穿（Cache Breakdown）**

#### **定义**  

缓存击穿是指**单个热点键（高频访问的缓存）突然失效**，导致短时间内大量请求直接打到数据库，引发数据库压力骤增。

#### **核心特征**  

- **单点失效**：仅一个（或少数几个）高频访问的缓存键过期。  
- **流量集中**：该键的请求量极大（如秒杀活动的热门商品）。  

#### **实际场景**  

- **热点数据过期**：秒杀活动中，某商品的缓存键（如`product:1001`）因过期失效，而该商品是千万级用户同时访问的热点。  

#### **示例**  

某网红手机新品发布，商品详情页的缓存键`product:20240901`被高频访问（每秒10万次）。当该缓存过期时：  

- 所有请求瞬间失去缓存保护 → 直接查询数据库。  
- 数据库无法处理每秒10万次的查询 → 响应延迟或崩溃。  

### **四、三者区别对比**

| 维度  | 缓存穿透 | 缓存雪崩 | 缓存击穿 |
| -----| ------| ------| ------|
| **触发原因**       | 查询不存在的数据            | 大量缓存集中失效/服务宕机    | 单个热点缓存突然失效        |
| **影响范围**       | 单个/少量无效请求           | 大量缓存失效，全局影响      | 单个热点键失效，局部高流量  |
| **数据库压力**     | 持续低效查询（无效数据）    | 瞬间高并发（全量请求）      | 瞬间高并发（热点请求）      |
| **典型场景**       | 恶意攻击、参数校验缺失      | TTL统一设置、缓存服务故障   | 热点数据过期（如秒杀商品）  |



### **五、解决方案**

#### **缓存穿透**  

- **布隆过滤器（Bloom Filter）**：在缓存前加布隆过滤器，预存所有存在的键。查询时先检查布隆过滤器，若不存在则直接返回空（避免查数据库）。  
- **缓存空值**：对查询结果为空的数据，在缓存中存储一个空值（如`null`），并设置短TTL（如5分钟），避免重复查询数据库。  
- **参数校验**：前端/后端对入参合法性校验（如ID必须为正整数），拦截无效请求。  

#### **缓存雪崩**  

- **分散TTL**：为缓存设置随机TTL（如基础时间±10%波动），避免大量缓存同时失效。  
- **多级缓存**：使用本地缓存（如Caffeine）+ 分布式缓存（如Redis），降低单一缓存失效的影响。  
- **缓存高可用**：部署Redis集群（主从+哨兵）或使用云缓存服务（如阿里云Redis），避免缓存服务整体宕机。  

#### **缓存击穿**  

- **互斥锁（分布式锁）**：当缓存失效时，仅允许一个线程查询数据库并重新填充缓存（其他线程等待锁释放），避免大量线程同时查数据库。  
- **永不过期（逻辑过期）**：缓存不设置物理TTL，而是存储逻辑过期时间（如`expire_time`字段）。查询时检查逻辑时间，若过期则异步更新缓存（旧数据仍可用）。  
- **热点数据预加载**：提前将热点数据（如秒杀商品）的缓存TTL延长，或在活动前主动刷新缓存。  

### **总结**  

三者均会导致数据库压力激增，但根源不同：  

- 穿透是**查不到** → 用布隆过滤器/空值缓存拦截无效请求；  
- 雪崩是**批量失效** → 分散TTL/多级缓存；  
- 击穿是**单点失效** → 互斥锁/逻辑过期。  

实际开发中需结合业务场景（如是否有恶意攻击、是否存在热点数据）选择组合方案。

### Reference
- [v2ex 缓存击穿迷惑的翻译](https://www.v2ex.com/t/1157654)